# Отчёт о выполнении задачи "Создание программы для обнаружения повышенного радиационного фона в трубах с паром на атомной электростанции"

- [Отчёт о выполнении задачи "Создание программы для обнаружения повышенного радиационного фона в трубах с паром на атомной электростанции"](#отчёт-о-выполнении-задачи-name)
  - [Постановка задачи](#постановка-задачи)
  - [Известные ограничения и вводные условия](#известные-ограничения-и-вводные-условия)
    - [Цели и Предположения Безопасности (ЦПБ)](#цели-и-предположения-безопасности-цпб)
  - [Архитектура системы](#архитектура-системы)
    - [Компоненты](#компоненты)
    - [Алгоритм работы решения](#алгоритм-работы-решения)
    - [Описание Сценариев (последовательности выполнения операций), при которых ЦБ нарушаются](#описание-сценариев-последовательности-выполнения-операций-при-которых-цб-нарушаются)
    - [Указание "доверенных компонент" на архитектурной диаграмме](#указание-доверенных-компонент-на-архитектурной-диаграмме)
    - [Политики безопасности](#политики-безопасности)
  - [Запуск приложения и тестов](#запуск-приложения-и-тестов)
    - [Запуск приложения](#запуск-приложения)
    - [Запуск тестов](#запуск-тестов)

## Постановка задачи
Предыдущая команда разработки ничего не знала о кибериммунном подходе и после быстрого анализа функциональной стороны вопроса на скорую руку реализовала некий прототип устройства детектировани (УД). Само УД сделано монолитом, внешние сервисы и ключ доступа имитируются отдельными процессами которые взаимодействуют с помощью REST запросов.
В результате нужно спроектировать кибериммунное УД, реализовать его функциональный прототип с похожими внешними интерфейсами, желательно добавить автотесты (функциональные и безопасности).

## Известные ограничения и вводные условия

### Краткое описание функционала и назначения продукта
Рассматриваемое устройство детектирования (УД) обрабатывает входящие сигналы от датчиков, в случае превышения порога срабатывания принимает решение о выдаче команды в систему управления защиты (СУЗ) реактора (автоматическое срабатывание). УД передаёт обработанные данные в автоматизированную систему управления технологическим процессом (АСУ ТП) АЭС для дальнейшей обработки, на основе этих данных оператор АСУ ТП может принять решение о выдаче команды в СУЗ (административное срабатывание).

### Начальные ограничения из текста задачи
1) Не рассматривается физическое воздействие на устройства.
2) Не рассматриваются риски, связанные с физическим отказом компонентов системы.

### Цели и Предположения Безопасности (ЦПБ)
Цели безопасности:
1) Только авторизованный оператор-технолог в присутствии оператора-безопасника может инициировать изменение настроек УД.
2) Только авторизованный оператор-безопасник в присутствии оператора-технолога может обновлять ПО УД.
3) УД сообщает о наличии аварийной ситуации на модуль СУЗ и не сообщает, если не произошла. 
4) УД отправляет на АСУ ТП целостные и достоверные данные.
5) Настройки для УД будут применены исключительно в том виде, как они были применены, либо не применены вообще.
6) Обновление будет либо применено той версии, которая хранится в файле, либо не применено вообще.


Предположения безопасности:
1) Не рассматриваются атаки, связанные с физическим доступом к оборудованию.
2) Не рассматриваются риски, связанные с физическим отказом внешнего оборудования, включая обесточивание УД.
3) Не рассматриваются риски, связанные с физическим отказом аппаратного обеспечения устройства.

## Архитектура системы
Приведем небольшую историю разработки существующей архитектуры.
### Этап первый. Наброски архитектуры.
Первоначально мы выделили пять основных групп поведения УД: работа с датчиками, настройка, обновление, связь с СУЗ и связь с АСУ ТП. В результате появилась первая архитектура, которая представлена на рисунке ниже.
![Image](https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/docs/images/Снимок-экрана-2023-04-22-в-14.06.19.jpeg/)
Зелеными стрелками представлено обычное функционирование, красными – аварийное, а синими – изменение конфигурации. 
На этом этапе у нас ещё остаются вопросы, касающиеся архитектуры, разбираемся с ними на следующем шаге.

### Этап второй. Понимание концепта.
Осознаём необходимость добавление модулей, ответственных за авторизацию, а также отделения компонентов загрузки.
![Image](https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/docs/images/Снимок-экрана-2023-04-22-в-14.07.51.jpeg/)
На этом этапе мы столкнулись с самой большой проблемой – отправлением данных в СУЗ. В данной архитектуре компрометация модуля “Связь с СУЗ” могла бы привести к неотправлению информации в аварийной ситуации. Аналогичная, хотя и менее важная проблема поджидала нас в “связи с АСУ ТП”, которая могла подделать посылаемые данные. Третья выделенная нами проблема стояла в обнаружении подмены в модуле настройки.
В то же время на этом шаге мы решили, что ответственность за логирование будет переложена на Кафку, а оба модуля будут записывать в топик информацию об авторизации, на которую будет опираться монитор безопасности для принятия решения. Эти архитектурные решения дошли с нами до конца.

### Этап третий. Размышления.
Решение для проблемы с настройкой пришло самым первым. Мы декомпозировали систему и обезопасили хранение при помощи хеша.
![Image](https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/docs/images/Снимок-экрана-2023-04-22-в-14.08.35.jpeg/)
Здесь же появилась идея использовать рукопожатия для подтверждения полученных данных, а модуль, ответственный за REST разделили на приемник, передатчик и валидатор.
Самым интересным вопросом, конечно, стала работа с СУЗ.
Приходим к трём потенциальным решениям проблемы. 
Оригинальная идея содержала в себе решение, удовлетворяющее цели безопасности — если мы ничего не отправляем в аварийной ситуации, то мы всё ещё “посылаем достоверные данные”, ведь мы ничего не посылаем. Такой вариант нас не устраивает.
Первое решение — возможность сделать элемент доверенным, при этом вынеся из него процесс создания http-запроса в отдельный модуль. Однако при компрометации модуля проблема сохраняется.

#### Решение 1
Тогда нам пришла в голову идея — инвертировать процесс передачи сообщений. В таком случае, пока всё хорошо, УД оповещал бы СУЗ по протоколу REST, а замолкал бы, когда всё становилось плохо. Так мы перевернули ситуацию: мы обязательно сообщаем об аварийной ситуации, но допускаем возможность ложного срабатывания аварийной системы.
![Image](https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/docs/images/Снимок-экрана-2023-04-22-в-14.09.07.jpeg/)
Как это работает: в нормальном состоянии, когда ни один модуль не скомпрометирован, связь с СУЗ создает пакет с информацией о том, что всё хорошо, а передатчик запрашивает у монитора безопасности разрешение на отправление и, получая его, отправляет пакет. 
Если скомпрометирован модуль “Связь с СУЗ”, и он не отдает новых пакетов, то передатчик работает с предыдущим сообщением.
Если скомпрометирован передатчик, то подделать пакет он не может, но может его не отправить – ложное срабатывание.
В аварийном состоянии модуль “Связь с СУЗ” генерирует пакеты о том, что всё плохо, а передатчик не отправляет их. 
Если скомпрометирован модуль “Связь с СУЗ”, то он не может повлиять на ситуацию – его пакеты и так не используются.
Если скомпрометирован передатчик, то он передает сообщения, в которых написано, что всё плохо или не передает ничего. 
Таким образом, СУЗ работает так, что пакеты “всё хорошо” утверждают, что всё хорошо, а вот пакеты “всё плохо” или молчание – аварийная ситуация.
Из показанного выше примера мы можем понять, что молчание передатчика – самая плохая ситуация, с которой мы можем столкнуться, ибо мы теряем любую связь с внешним миром, и даже если мы как-то поймем, что запрос не был отправлен, мы ничего не сможем сделать.

#### Решение 2
![Image](https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/docs/images/Снимок-экрана-2023-04-22-в-14.10.47.jpeg/)
Сделав передатчик достоверным, мы избавились от возможности ложного оповещения, но сделали доверенным модуль, использующий достаточно большую и мощную библиотеку, что не выглядит хорошо.

#### Решение 3
Помимо доверенности мы думали о том, чтобы кодировать решение от двух модулей сразу, например, пусть связь с СУЗ генерирует содержание тела запроса, а передатчик отправляет сообщения с разной частотой в панику и нет, тогда несоответствие их результатов будет сигнализировать о повреждениях УД, искали третий механизм задания аварийной ситуации (как тело и частота), но все идеи разбивались об передатчик, который просто не отправляет ничего.
В итоге мы остановились на третьем решении, которое заключается в дублировании передатчиков и механизме обратной связи для выявления компрометации.
![Image](https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/docs/images/Снимок-экрана-2023-04-22-в-14.12.57.jpeg/)
Мы вводим в систему два передатчика, основанных на различных библиотеках python, чтобы уменьшить вероятность компрометации обоих модулей одновременно, так как при различиях в реализации все они обладают одинаковой функциональностью. 
При нормальном функционировании, первый передатчик отправляет по собственному URL пакеты через равный промежуток времени, а второй молчит.
При аварийном функционировании, первый передатчик замолкает, тогда как второй начинает отправлять тревожные пакеты на собственный URL.
При наличии скоординированных данных от двух передатчиков, СУЗ принимает их заявление как действительное, но при смешанных результатах, он отправляет запрос на приемник, с указанием полученных данных, чтобы валидатор смог оценить, какой из двух передатчиков ведет себя некорректно. У валидатора есть данные о реальном состоянии системы (из топика Кафки), а также о сообщениях от обоих передатчиках.
Таким образом:

| Статус     | Сообщение №1 | Сообщение №2 | Вердикт           |
|------------|--------------|--------------|-------------------|
| Нормальное | молчание     | молчание     | Неисправен первый |
| Аварийное  | молчание     | молчание     | Неисправен второй |
| Нормальное | трансляция   | трансляция   | Неисправен второй |
| Аварийное  | трансляция   | трансляция   | Неисправен первый |

В таком случае, валидатор использует исправный передатчик для отправление последнего пакета. 
Почему это хорошо?
Во-первых, мы можем не бояться, что какой-либо из скомпрометированных модулей будет притворяться хорошим, а потом обманет – даже если он попытается послать третий пакет, СУЗ не будет его ожидать, а значит обман не пройдет.
Во-вторых, просто так послать третий пакет не получится, между СУЗ и УД происходит обмен сообщениями – СУЗ ожидает получить тот же ключ, что пересылал в запросе.

Для финальной архитектуры мы выбрали именно это решение.

#### Итоговое решение.

Мы решиили отталкиваться от принципа максимально возможной эффективной декомпозиции с минимально возможным количеством доверенных компонент. Таким образом, каждый из наших модулей выполняет одну небольшую ключевую функцию, обеспечивая многоэтапную проверку передаваемых данных.
![Image](https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/docs/images/photo_2023-04-23_07.50.27.jpeg/)
К сожалению, мы не успели реализовать финальную архитектуру ввиду ее сложности. В данный момент используется решение 3 в конфигурации "При нормальном функционировании, оба передатчика молчат. При аварийном функционировании, оба передатчика сообщают о неполадках."

### Компоненты
| Название модуля         | Функциональность                                                  | Комментарий                                                                                          |
|-------------------------|-------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|
| Авторизация оператора-технолога   | Ввод и проверка данных авторизации для опреатора-технолога.                 |                                                                                                      |
| Авторизация оператора КБ | Ввод и проверка данных авторизации для оператора КБ.               |                                                                                                      |
| Загрузчик               | Загрузка файла обновления из файловой системы.                    |                                                                                                      |
| Запись (блок Обновление)     | Обработка данных, полученных загрузчиком и хранение оных.         |                                                                                                      |
| Обновление              | Выполнение обновления системы.                                    |                                                                                                      |
| Валидатор (блок Обновление)  | Проверка хранимого обновления на валидность.                      | В текущей версии достаточно примитивен вследствие недостатка времени. Планируется проверка чексуммы  |
| Ввод                    | Чтение данных настройки.                                          |                                                                                                      |
| Запись (блок Настройка)      | Обработка данных, полученных из ввода и хранение оных.            |                                                                                                      |
| Настройка               | Донесение информации об обновлении до прочих модулей.             | В частности для модуля ADP                                                                           |
| ADP (или Обнаружение)   | Проверка данных и определение необходимости посыла сигнала на СУЗ |                                                                                                      |
| Хеш-счетчик             | Расчет хеша для входных данных.                                   |                                                                                                      |
| Передатчик (urllib3)    | Отправление запросов на СУЗ и АСУ ТП                              | Передатчики дублируется для повышения надежности.                                                    |
| Передатчик (pycurl)     | Отправление запросов на СУЗ и АСУ ТП                              | Подробнее см. часть про архитектуру.                                                                 |
| Приемник                | Прием запросов от СУЗ и АСУ ТП                                    |                                                                                                      |
| Валидатор               | Проверка состояния УД                                             | Подробнее см. архитектуру                                                                            |
| Монитор безопасности    | Контроль за передаваемыми сообщениями                             |                                                                                                      |
| Брокер сообщений        | Передача сообщений между модулями.                                | Одновременно выполняет функции логирования                                                           |

### Алгоритм работы решения
Рассмотрим алгоритм работы каждого из компонентов.

#### Общие понятия
**Обновление**
1) Пусть в файле будет число – новая версия продукта;
2) Загрузчик передает данные строкой;
3) Запись преобразует данные в число;
4) Валидатор проверяет, что число на один больше предыдущего.

**Настройка**
1) Пусть ожидается ввод одной строки;
2) Ввод передается на запись в виде строки;
3) В записи сохраняется как два числа;
4) Хэш считается от перевода в строку.

#### Алгоритм работы модулей
**Авторизация**
1) Ожидает данные на вход
2) Вводятся данные авторизации (input)
3) Данные проверяются
4) Если данные верну,  записывается в auth-name, что авторизация прошла
5) Записывает в log попытку авторизации (успешную / неуспешную)
6) Отправляет сигнал в ввод/загрузчик (кафка через монитор)
6) Отправляет сигнал в настройка/обновление  (кафка через монитор)
7) Ожидает новых сообщений в собственном канале (auth-name)
8) При получении сообщения, повторяет все с первого шага
9) Все действия логируются

**Загрузчик**
1) Consumer (downloader) получает сигнал от модуля авторизации
2) Локально читает файл
3) Записывает в log, что файл был загружен
4) Посылает через producer в модуль записи (writer_upd) (кафка через монитор)
5) Все действия логируются

**Запись (блок обновление)**
1) Считывает данные из кафки со своего топика (writer_upd)
2) Если данные поступили от downloader, то обрабатывает и сохраняет локально
3) Если данные поступили от update, то отправить данные в топик валидатора
4) Все действия логируются

**Обновление**
1) При получении данных от авторизации – отправляет данные в запись (обновление)
2) При получении данных от валидатора – записывает новое значение версии
3) Записывает deauthorization в канал авторизации auth-tech и auth-sec
4) Все действия логируются

**Валидатор (блок обновление)**
1) Считывает данные из канала от записи
2) Валидирует
3) Записывает данные в канал для обновления
4) Все действия логируются

**Ввод**
1) Считывает значение из стандартного ввода в виде строки
2) Записывает в лог, что значение было взято
3) Передает данные в writer_set
4) Все действия логируются

**Запись (блок Настройка)**
1) Считывает данные из кафки со своего топика (writer_set)
2) Если данные поступили от input, то обрабатывает и сохраняет локально
3) Если данные поступили от ADP, то отправляет данные в топик hash
4) Все действия логируются

**Настройка**
1) Если пришли данные от авторизации, ожидает получения хэша 
2) При получении верного хэша записывает данные в обнаружение
3) Все действия логируются

**Хэш**
1) Если пришло сообщение от ввода, рассчитывает хэш и отправляет его в настройку
2) Если пришло сообщение от записи, то переводит полученные числа в строку с пробелом, рассчитывает хэш от нее, и отправляет в обнаружение хэш и два числа, которые пришли от записи
3) Все действия логируются

**Обнаружение**
1) Если пришло сообщение от модуля настройки, то сохраняет хэш, отправляет сообщение к модулю записи
2) Если пришло сообщение от модуля хэша – сравнивает с тем, что было получено ранее (если ранее ничего не было получено – записывает в лог и больше ничего не делает)
3) Если сравнение выполнено успешно, заменяет глобальные переменные на полученные значения
4) В любом случае записывает deauthorization в канал авторизации auth-tech и auth-sec
5) В отдельном потоке раз в некоторый промежуток времени вызывает функцию, которая находит случайное число в определенных пределах - имитация проверки от датчика
6) Сравнивает это значение с глобальными переменными
7) Если оно больше – посылает в каналы transmitter сообщения одного из типов: info, warning, fatal и полученное значение
8) Если fatal, записывает в details payload аналогичное сообщение
9) Все действия логируются

**Оба передатчика**
1) Если получены данные на свой канал от модуля обнаружения c меткой info – создает http-запрос, в тело помещает текущее число (уровень радиоактивности) и послыет его на 6069/data при помощи метода post с содержанием в виде json-файла
2) Если получены данные на свой канал от модуля обнаружения с меткой warning или fatal – создает http-запрос с телом json и отправляет его на 6068/alarm
3) Если получает сигнал от валидатора, послает данные на 6068/check
4) Все действия логируются

**Приемник**
1) Принимает запросы с содержанием по типу json
2) Посылает четыре значения в валидатор
3) Все действия логируются

**Валидатор**
1) Принимает из приемника значения
2) Считывает статус из канала
3) Определяет неисправный приемник
4) Отправляет другому приемнику сообщение в со статусом и ключом
5) Все действия логируются


### Описание Сценариев (последовательности выполнения операций), при которых ЦБ нарушаются

1. Скомпрометирован модуль “Авторизация технолога”: происходит инициализация смены настроек без непосредственно авторизованных людей. 
**Нарушение ЦБ №1.**

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.29.34.png" height="300">

Решение: политика безопасности запрещает инициализацию без наличия информации об авторизации от обоих модулей авторизации.

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.34.21.png" height="300">

2. Скомпрометирован модуль “Авторизация оператора КБ”: происходит инициализация обновления без непосредственно авторизованных людей. **Нарушение ЦБ №2.**
<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.29.47.png" height="300">

Решение: см. п. 1.

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.34.31.png" height="300">

3. Скомпрометирован модуль “Настройка”: посылает сигнал модулю “Обнаружение” о необходимости обновления. **Нарушение ЦБ №1.**

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.30.03.png" height="300">

Решение: политика безопасности запрещает производить передачу сообщения от “Настройки” к “Обнаружению” без состояния модификации, задаваемого монитором безопасности.

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.34.41.png" height="300">

4. Скомпрометирован модуль “Запись”: попытка подменить данные настроек при переводе значений. **Нарушение ЦБ №5.**
<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.30.18.png" height="300">

Решение: использование криптографических методов для сравнения исходных данных в бинарном формате и переданного объекта.

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.34.51.png" height="300">

5. Скомпрометирован модуль “Обновление": посылает запрос модулю “Запись” о загрузке обновления. **Нарушение ЦБ №2.**
<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.30.35.png" height="300">

Решение: политика безопасности запрещает производить передачу сообщения от “Обновление” к “Запись” без состояния обновления, задаваемого монитором безопасности.

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.35.03.png" height="300">

6. Скомпрометирован модуль “Запись”: попытка подменить или исказить прошивку при переводе значений. **Нарушение ЦБ №6.**

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.30.47.png" height="300">

Решение: использование криптографических методов для валидации данных, лежащих в загрузке.

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.35.13.png" height="300">

7. Скомпрометирован модуль “Передатчик”: передатчик отказывается посылать данные на СУЗ. **Нарушение ЦБ №3.**

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.30.58.png" height="300">

Решение: проблема решена дублированием модулей, так как из наших предположений безопасности компрометация более чем одного устройства невозможна ввиду детектирования первого нежелательного срабатывания Монитором безопасности.

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.35.23.png" height="300">

8. Скомпрометирован модуль “Передатчик”: передатчик посылает на СУЗ противоположные (неверные) данные. **Нарушение ЦБ №3.**

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.31.10.png" height="300">

Решение: использование механизма обратной связи для подтверждения результатов, переданных передатчиками.

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/docs/images/photo_2023-04-23_15-24-21.jpg" height="300">

9. Скомпрометирован модуль “Передатчик”: передатчик отказывается посылать данные на АСУ ТП. **Нарушение ЦБ №4.**

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.31.26.png" height="300">

Решение: см. п. 7.

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.35.50.png" height="300">

10. Скомпрометирован модуль “Передатчик”: передатчик посылает на АСУ ТП противоположные (неверные) данные. **Нарушение ЦБ №4.**

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/scenario/Снимок%20экрана%202023-04-23%20в%2010.31.37.png" height="300">

Решение: см. п. 8.

<img src="https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/docs/images/photo_2023-04-23_15-24-24.jpg" height="300">


### Указание "доверенных компонент" на архитектурной диаграмме.

Мы полагаем доверенным модуль аналогово-дикретного преобразователя (или модуля обнаружения), на котором сигнал от датчиков сравнивается с допустимым.

Обосновать доверенность этого компонента можно его низкой сложностью кода, а значит минимальных ресурсов проверки, а также критичностью его компрометации.

Также доверенными считаюся любые сигналы и данные пришедные впервые со сторонних устройств, т.е. случай со сценарием обратимости на проверку от СУЗ/АСУ ТП сюда не включаем.

Брокер сообщений по умолчанию считаем доверенными, через них проходят абсолютно все соединения между модулями.

![Image](https://git.codenrock.com/cyberimmune/cnrprod-team-28637/npp/raw/main/docs/images/photo_2023-04-23_07.50.27.jpeg/)


### Политики безопасности 


```python {lineNo:true}
SEC_AUTH = False
TECH_AUTH = False

def check_authorization():
    global SEC_AUTH, TECH_AUTH
    return TECH_AUTH and SEC_AUTH

def check_operation(id, details):
    authorized = False
    # print(f"[debug] checking policies for event {id}, details: {details}")
    print(f"[info] checking policies for event {id},"\
          f" {details['source']}->{details['destination']}: {details['operation']}")
    src = details['source']
    dst = details['destination']
    operation = details['operation']
    if  src == 'downloader' and dst == 'log' \
        and operation == 'logging':
        authorized = True   
    if  src == 'downloader' and dst == 'writer_upd' \
        and operation == 'write_update':
        authorized = True    
    if  src == 'update' and dst == 'log' \
        and operation == 'logging':
        authorized = True
    if  src == 'update' and dst == 'writer_upd' \
        and operation == 'validate_update':
        authorized = True           
    if src == 'update' and dst == 'auth_sec' \
        and operation == 'deauthorization':
        authorized = True    
    if src == 'update' and dst == 'auth_tech' \
        and operation == 'deauthorization':
        authorized = True    
    if src == 'validator_upd' and dst == 'log' \
        and operation == 'logging':
        authorized = True    
    if src == 'validator_upd' and dst == 'update' \
        and operation == 'apply_update':
        authorized = True    
    if src == 'writer_upd' and dst == 'log' \
        and operation == 'logging':
        authorized = True    
    if src == 'writer_upd' and dst == 'validator_upd' \
        and operation == 'validate_update ':
        authorized = True    


    if  src == 'ADP' and dst == 'log' \
        and operation == 'logging':
        authorized = True   
    if  src == 'ADP' and dst == 'writer_set' \
        and operation == 'get_settings':
        authorized = True    
    if  src == 'ADP' and dst == 'auth_sec' \
        and operation == 'deauthorization':
        authorized = True
    if  src == 'ADP' and dst == 'auth_tech' \
        and operation == 'deauthorization':
        authorized = True     


    if src == 'auth_sec' and dst == 'log' \
        and operation == 'logging':
        authorized = True
    if src == 'auth_sec' and dst == 'update' \
        and operation == 'apply_update':
        authorized = True and check_authorization()   
    if src == 'auth_sec' and dst == 'downloader' \
        and operation == 'download_update':
        authorized = True and check_authorization()   
    if src == 'auth_sec' and dst == 'auth_sec' \
        and operation == 'authorization':
        authorized = True
    if src == 'auth_tech' and dst == 'log' \
        and operation == 'logging':
        authorized = True
    if src == 'auth_tech' and dst == 'settings' \
        and operation == 'change_settings':
        authorized = True and check_authorization()   
    if src == 'auth_tech' and dst == 'input' \
        and operation == 'input_update':
        authorized = True and check_authorization()  
    if src == 'auth_tech' and dst == 'auth_tech' \
        and operation == 'authorization':
        authorized = True   
    if src == 'hash' and dst == 'log' \
        and operation == 'logging':
        authorized = True    
    if src == 'hash' and dst == 'settings' \
        and operation == 'send_hash':
        authorized = True    
    if src == 'hash' and dst == 'ADP' \
        and operation == 'apply_settings':
        authorized = True    
    if src == 'input' and dst == 'log' \
        and operation == 'logging':
        authorized = True
    if src == 'input' and dst == 'writer_set' \
        and operation == 'send_value':
        authorized = True    
    if src == 'settings' and dst == 'log' \
        and operation == 'logging':
        authorized = True    
    if src == 'settings' and dst == 'ADP' \
        and operation == 'send_hash':
        authorized = True    
    if src == 'writer_set' and dst == 'hash' \
        and operation == 'calculate_hash':
        authorized = True    
    if  src == 'receiver' and dst == 'log' \
            and operation == 'logging':
            authorized = True
    if  src == 'receiver' and dst == 'validator_out ' \
            and operation == 'validate_command':
            authorized = True
    if  src == 'transmitter' and dst == 'log' \
            and operation == 'logging':
            authorized = True
    if  src == 'validator_out' and dst == 'log' \
            and operation == 'logging':
            authorized = True
    if  src == 'validator_out' and dst == 'transmitter1 ' \
            and operation == 'transmit_message':
            authorized = True
    if  src == 'validator_out' and dst == 'transmitter2 ' \
            and operation == 'transmit_message':
            authorized = True
    if  src == 'ADP' and dst == 'transmitter' \
            and operation == 'transmit_message':
            authorized = True     

    # kea - Kafka events analyzer - an extra service for internal monitoring,
    # can only communicate with itself
    if src == 'kea' and dst == 'kea' \
        and (operation == 'self_test' or operation == 'test_param'):
        authorized = True
    
    return authorized
```

## Запуск приложения и тестов

**Примечание:** код включает в себя основные принципы описанной выше архитектуры, но на данный момент функциональный запуск в этой реализации происходит с ошибками.

В коде была реализована идея архитектуры и проверена функциональная работа компонентов, связанных с настройкой УД и обновлением ПО УД (взаимодействие между компонентами происходит успешно, настройка и обновление осуществляются корректно с монитором безопасности), но в контексте авторизации они не могут начать данные функциональные сценарии (из-за ошибок в реализации авторизации в коде она не проходит через монитор безопасности).

Идея архитектуры также была реализована в коде и для остальных компонентов, связанных с обработкой входящих сигналов от датчиков и административным и автоматическим срабатываниями, но их работу не удалось проверить.

### Запуск приложения

см. [инструкцию по запуску](README.md)

### Запуск тестов

_Предполагается, что в ходе подготовки рабочего места все системные пакеты были установлены._

Запуск примера: открыть окно терминала в Visual Studio code, в папке с исходным кодом выполнить 

**make prepare**

**make run**
или **docker-compose up -d**

При запуске система ожидает авторизации оператора-технолога и оператора КБ через POST-запросы с ключом в теле.
